; A CONL schema is a way to validate a CONL document.
;
; A schema defines a number of definitions (most importantly the "root")
; against which a document can be matched.
;
; The expressivity of CONL schema is roughly the same as that of a regular expression.
; This makes it good for a first-pass validation, but there will likely always be some
; cases where post-validation is required.
;
; This document is a meta-schema. It is a schema the defines the possible valid schemas,
; and validates against itself.
root
  required keys
    ; The root is matched against the top level of the document.
    ; It will most often be a <map>.
    root = <definition>
  keys
    ; Additional definitions can be added as needed, and refered to
    ; using the <definition> syntax.
    .* = <definition>
    ; allow a CONL Schema definition too.
    schema = .*

; A definition represents a single type in a CONL document.
; In addition to the three CONL types (scalar, map and list)
; A "one of" definition represents a logical OR of possible definitions
; (potentially of different types).
definition
  one of
    = <scalar>
    = <map>
    = <list>
    = <one of>

; Definitions are built on matchers, which can either be regular expressions
; to match scalars, or references to other definitions in the schema.
matcher
  one of
    = <regexp>
    = <reference>

; references refer to a definition elsewhere in the schema
; references with no matching definition, or circular references
; are not allowed.
reference
  scalar = \<.*>

; Regular expressions are used to match scalars.
;
; Regular expression engines have different interpretations of syntax.
; That said, if you stick to a common subset you should be fine.
;
; A few things to note:
; = The pattern is anchored. Implementors may need to add ^ and $ to the pattern.
; = The . character matches any unciode character. Implementors may need to set the "s" flag to match \n.
; = The grouping and alternation operators (),  (?:) and } should work.
; = The quantifiers {a,b}, ?, * and + should work (for reasonable values of a and b).
; = The syntax of [] containing unicode characters or ranges should work.
;
; If you choose to use regex features beyond that, be aware that the results of matching
; will be implementation dependendant.
regexp
  scalar = [^<].*


; A scalar definition matches a scalar against the given matcher.
; In practice this means that the matcher must either be a regular expression,
; or a reference to a scalar definition (or a one-of that contains scalar definitions).
scalar
  required keys
    scalar = <matcher>

; A "one of" definition represents an OR of possible definitions.
; This is the primary mechanism in CONL schema to allow a value to have
; more than one type; but it is also useful when a value is a discriminated
; union.
one of
  required keys
    one of = <matcher list>

matcher list
  items = <matcher>

; A "map" definition matches a CONL map.
; It must have either required keys or keys,
map
  one of
    = <required map>
    = <allowed map>

required map
  required keys
    required keys = <map keys>
  keys
    keys = <map keys>

allowed map
  required keys
    keys = <map keys>

map keys
  keys
    ; The keys of the maps are also matchers.
    ; They can be either regular expressions or references to other definitions.
    <matcher> = <matcher>

list
  one of
    = <required list>
    = <allowed list>
required list
  required keys
    required items = <matcher list>
  keys
    items = <matcher>
allowed list
  required keys
    items = <matcher>
